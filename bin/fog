#!/usr/bin/env ruby
require File.join(File.dirname(__FILE__), '..', 'lib', 'fog')
require 'irb'
require 'yaml'

module Fog
  module Credentials
    Fog.credential = (ARGV.first && :"#{ARGV.first}") || :default
    unless Fog.credentials
      exit
    end
  end
end

module AWS
  class << self
    credential = (ARGV.first && :"#{ARGV.first}") || :default
    if Fog.credentials[:aws_access_key_id] && Fog.credentials[:aws_secret_access_key]

      def initialized?
        true
      end

      def [](service)
        @@connections ||= Hash.new do |hash, key|
          credentials = Fog.credentials.reject do |k, v|
            ![:aws_access_key_id, :aws_secret_access_key].include?(k)
          end
          hash[key] = case key
          when :ec2
            Fog::AWS::EC2.new(credentials)
          when :s3
            Fog::AWS::S3.new(credentials)
          end
        end
        @@connections[service]
      end

      def addresses
        self[:ec2].addresses
      end

      def directories
        self[:s3].directories
      end

      def flavors
        self[:ec2].flavors
      end

      def images
        self[:ec2].images
      end

      def servers
        self[:ec2].servers
      end

      def key_pairs
        self[:ec2].key_pairs
      end

      def security_groups
        self[:ec2].security_groups
      end

      def snapshots
        self[:ec2].snapshots
      end

      def volumes
        self[:ec2].volumes
      end

    else

      def initialized?
        false
      end

    end
  end
end

module Rackspace
  class << self
    if Fog.credentials[:rackspace_api_key] && Fog.credentials[:rackspace_username]

      def initialized?
        true
      end

      def [](service)
        @@connections ||= Hash.new do |hash, key|
          credentials = Fog.credentials.reject do |k,v|
            ![:rackspace_api_key, :rackspace_username].include?(k)
          end
          hash[key] = case key
          when :files
            Fog::Rackspace::Files.new(credentials)
          when :servers
            Fog::Rackspace::Servers.new(credentials)
          end
        end
        @@connections[service]
      end

      def flavors
        self[:servers].flavors
      end

      def images
        self[:servers].images
      end

      def servers
        self[:servers].servers
      end
      
    else

      def initialized?
        false
      end

    end
  end
end

module Slicehost
  class << self
    if Fog.credentials[:slicehost_password]

      def initialized?
        true
      end

      def [](service)
        @@connections ||= Hash.new do |hash, key|
          credentials = Fog.credentials.reject do |k,v|
            ![:slicehost_password].include?(k)
          end
          hash[key] = case key
          when :slices
            Fog::Slicehost.new(credentials)
          end
        end
        @@connections[service]
      end

      def flavors
        self[:slices].flavors
      end

      def images
        self[:slices].images
      end

      def servers
        self[:slices].servers
      end

    else

      def initialized?
        false
      end

    end
  end
end

module Terremark
  class << self
    if Fog.credentials[:terremark_password] && Fog.credentials[:terremark_username]

      def initialized?
        true
      end

      def [](service)
        @@connections ||= Hash.new do |hash, key|
          credentials = Fog.credentials.reject do |k,v|
            ![:terremark_username, :terremark_password].include?(k)
          end
          hash[key] = case key
          when :vcloud
            Fog::Terremark.new(credentials)
          end
        end
        @@connections[service]
      end

    end
  end
end

module Fog
  class << self

    def services
      services = []
      [::AWS, ::Rackspace, ::Slicehost].each do |service|
        if service.initialized?
          services << service
        end
      end
      services
    end

    def flavors
      flavors = {}
      services.each do |service|
        flavors[service] = service.flavors
      end
      flavors
    end

    def images
      images = {}
      services.each do |service|
        images[service] = service.images
      end
      images
    end

    def servers
      servers = {}
      services.each do |service|
        servers[service] = service.servers
      end
      servers
    end

  end
end

ARGV.clear # Avoid passing args to IRB
IRB.setup(nil)
@irb = IRB::Irb.new(nil)
IRB.conf[:MAIN_CONTEXT] = @irb.context
@irb.context.workspace = IRB::WorkSpace.new(binding)
catch(:IRB_EXIT) { @irb.eval_input }
