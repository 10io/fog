require 'fog/core/model'
require 'fog/compute/models/libvirt/util'
require 'net/ssh/proxy/command'
require 'rexml/document'
require 'erb'
require 'securerandom'


module Fog
  module Compute
    class Libvirt

      class Server < Fog::Model

        include Fog::Compute::LibvirtUtil

        identity :id, :aliases => 'uuid'

        attribute :cpus
        attribute :os_type
        attribute :memory_size
        attribute :name

        attribute :poolname
        attribute :xml
        attribute :create_persistent
        attribute :template_options
        attribute :template_erb

        attr_accessor :password
        attr_writer   :private_key, :private_key_path, :public_key, :public_key_path, :username

        # Can be created by passing in :xml => "<xml to create domain/server>"
        # or by providing :template_options => {
        #                :name => "", :cpus => 1, :memory_size => 256 , :volume_template
        #   :}
        #
        # @returns server/domain created
        def initialize(attributes={} )
          self.xml  ||= nil unless attributes[:xml]
          self.create_persistent ||=true unless attributes[:create_persistent]
          self.template_options ||=nil unless attributes[:template_options]
          super
        end

        def save

          raise Fog::Errors::Error.new('Resaving an existing object may create a duplicate') if uuid

          # first check if we have either xml or template_options
          if xml.nil? && template_options.nil?
            raise Fog::Errors::Error.new('Creating a new domain/server requires either xml or passing template_options')
          end

          if !xml.nil? && !template_options.nil?
            raise Fog::Errors::Error.new('Creating a new domain/server requires either xml or passing template_options,not both')
          end

          # We have a template, let's generate some xml for it
          if !template_options.nil?

            template_defaults={
              :cpus => 1,
              :memory_size => 256,
              :arch => "x86_64",
              :os => "hvm",
              :domain_type => "kvm",
              :name => "fog-#{SecureRandom.random_number*10E14.to_i.round}",

              # Network options
              :interface_type => "nat", #or "bridge"
                :nat_network_name => "default",
                :bridge_name => "br0",

                # Disk options
                :disk_type => "raw",
                :disk_size => 10,
                :disk_size_unit => "G",
                :disk_allocate => 1,
                :disk_allocate_unit => "G",
                :disk_extension => "img",
                :disk_template_name => nil,
                :poolname => nil,

                # DVD options
                :iso_file => nil ,
                :iso_dir => "/var/lib/libvirt/images/"
            }


            template_options2=template_defaults.merge(template_options)
            template_options={
              :disk_name => "#{template_options2[:name]}.#{template_options2[:disk_extension]}"
            }.merge(template_options2)

            validate_template_options(template_options)


            if !template_options[:disk_template_name].nil?
              # Clone the volume
              volume=connection.volumes.all(:name => template_options[:disk_template_name]).first.clone("#{template_options[:disk_name]}")

              # This gets passed to the domain to know the path of the disk
              template_options[:disk_path]=volume.path
            else
              # If no template volume was given, let's create our own volume
              volume=connection.volumes.create(:template_options => {
                :name => "#{template_options[:disk_name]}",
                :extension => "#{template_options[:disk_extension]}",
                :type => "#{template_options[:disk_type]}",
                :size => "#{template_options[:disk_size]}",
                :size_unit => "#{template_options[:disk_size_unit]}",
                :allocate => "#{template_options[:disk_allocate]}",
                :allocate_unit => "#{template_options[:disk_allocate_unit]}" })

                # This gets passed to the domain to know the path of the disk
                template_options[:disk_path]=volume.path

            end

            xml=xml_from_template(template_options)

          end

          # We either now have xml provided by the user or generated by the template
          if !xml.nil?
            domain=nil
            if create_persistent
              domain=connection.define_domain_xml(xml)
            else
              domain=connection.create_domain_xml(xml)
            end
            self.raw=domain
          end
        end

        def validate_template_options(template_options)
          #if template_options[:disk_template_name].nil?
          #  raise Fog::Errors::Error.new('In order to make the disk boot, we require a template volume we can clone')
          #end
          unless template_options[:interface_type].nil?
            raise Fog::Errors::Error.new("#{template_options[:interface_type]} is not a supported interface type") unless ["nat", "bridge"].include?(template_options[:interface_type])
          end

        end

        def xml_from_template(template_options)

          # We only want specific variables for ERB
          vars = ErbBinding.new(template_options)
          template_path=File.join(File.dirname(__FILE__),"templates","server.xml.erb")
          template=File.open(template_path).readlines.join
          erb = ERB.new(template)
          vars_binding = vars.send(:get_binding)
          result=erb.result(vars_binding)
          return result
        end

        def username
          @username ||= 'root'
        end

        def start
          requires :raw

          unless @raw.active?
            begin
              @raw.create
              true
            rescue
              false
            end
          end
        end

        def destroy(options={ :destroy_volumes => false})

          #connection.volumes(name).destroy
          requires :raw
          if @raw.active?
            @raw.destroy
          end
          @raw.undefine
        end


        def reboot
          requires :raw

          @raw.reboot
        end

        def halt
          requires :raw

          @raw.halt
        end

        def poweroff
          requires :raw
          @raw.destroy
        end

        def shutdown
          requires :raw

          @raw.shutdown
        end

        def resume
          requires :raw

          @raw.resume
        end

        def suspend
          requires :raw

          @raw.suspend
        end

        def state
          state=case @raw.info.state
                when 0 then :nostate
                when 1 then :running
                when 2 then :paused
                when 3 then :shuttingdown
                when 4 then :shutoff
                when 5 then :crashed
                end
          return state
        end

        def ready?
          state == :running
        end


        def stop
          requires :raw

          @raw.shutdown
        end

        def xml_desc
          requires :raw
          raw.xml_desc
        end

        ##Note this requires arpwatch to be running
        ##and chmod o+x /var/lib/arpwatch

        # This retrieves the ip address of the mac address
        # It returns an array of public and private ip addresses
        # Currently only one ip address is returned, but in the future this could be multiple
        # if the server has multiple network interface
        #
        def addresses(options={})
          mac=self.mac

          # Check if another ip_command string was provided
          ip_command=options[:ip_command].nil? ? "grep #{mac} /var/log/arpwatch.log |cut -d ':' -f 4-| cut -d ' ' -f 4" : options[:ip_command]

          ip_address=nil

          if @connection.uri.ssh_enabled?

            # Retrieve the parts we need from the connection to setup our ssh options
            user=connection.uri.user #could be nil
            host=connection.uri.host
            keyfile=connection.uri.keyfile
            port=connection.uri.port

            # Setup the options
            ssh_options={}
            ssh_options[:keys]=[ keyfile ] unless keyfile.nil?
            ssh_options[:port]=port unless keyfile.nil?
            ssh_options[:paranoid]=true if connection.uri.no_verify?

            # TODO: we need to take the time into account, when IP's are re-allocated, we might be executing
            # On the wrong host

            begin
              result=Fog::SSH.new(host, user, ssh_options).run(ip_command)
            rescue Errno::ECONNREFUSED
              raise Fog::Errors::Error.new("Connection was refused to host #{host} to retrieve the ip_address for #{mac}")
            rescue Net::SSH::AuthenticationFailed
              raise Fog::Errors::Error.new("Error authenticating over ssh to host #{host} and user #{user}")
            end

            #TODO: We currently just retrieve the ip address through the ip_command
            #TODO: We need to check if that ip_address is still valid for that mac-address

            # Check for a clean exit code
            if result.first.status == 0
              ip_address=result.first.stdout.strip
            else
              # We got a failure executing the command
              raise Fog::Errors::Error.new("The command #{ip_command} failed to execute with a clean exit code")
            end

          else
            # It's not ssh enabled, so we assume it is 
            if @connection.uri.transport=="tls"
              raise Fog::Errors::Error.new("TlS remote transport is not currently supported, only ssh")
            end

            # Execute the ip_command locally
            IO.popen("#{ip_command}") do |p|
              p.each_line do |l|
                  ip_address=+l
              end
              status=Process.waitpid2(p.pid)[1].exitstatus
              if status!=0
                raise Fog::Errors::Error.new("The command #{ip_command} failed to execute with a clean exit code")
              end
            end

          end

          if ip_address==""
            #The grep didn't find an ip address result"
            ip_address=nil
          else
            # To be sure that the command didn't return another random string
            # We check if the result is an actual ip-address
            # otherwise we return nil
            unless ip_address=~/^(\d{1,3}\.){3}\d{1,3}$/
              raise Fog::Errors::Error.new(
                "The command #{ip_command} failed to execute with a clean exit code\n"+
                "Result was: #{ip_address}\n"
                )
            end
          end

          return { :public => [ip_address], :private => [ip_address]}
        end

        def private_ip_address
          ip_address(:private)
        end

        def public_ip_address
          ip_address(:public)
        end

        def ip_address(key)
          ips=addresses[key]
          unless ips.nil?
            return ips.first
          else
            return nil
          end
        end

        def private_key_path
          @private_key_path ||= Fog.credentials[:private_key_path]
          @private_key_path &&= File.expand_path(@private_key_path)
        end

        def private_key
          @private_key ||= private_key_path && File.read(private_key_path)
        end

        def public_key_path
          @public_key_path ||= Fog.credentials[:public_key_path]
          @public_key_path &&= File.expand_path(@public_key_path)
        end

        def public_key
          @public_key ||= public_key_path && File.read(public_key_path)
        end

        def ssh(commands)
          requires :public_ip_address, :username

          #requires :password, :private_key
          ssh_options={}
          ssh_options[:password] = password unless password.nil?
          ssh_options[:key_data] = [private_key] if private_key
          ssh_options[:proxy]= ssh_proxy unless ssh_proxy.nil?

          Fog::SSH.new(public_ip_address, @username, ssh_options).run(commands)

        end


        def ssh_proxy
          proxy=nil
          if @connection.uri.ssh_enabled?
            relay=connection.uri.host
            user_string=""
            user_string="-l #{connection.uri.user}" unless connection.uri.user.nil?
            proxy = Net::SSH::Proxy::Command.new("ssh #{user_string} "+relay+" nc %h %p")
            return proxy
          else
            return nil
            # This is a direct connection, so we don't need a proxy to be set
          end
        end

        # Transfers a file
        def scp(local_path, remote_path, upload_options = {})
          requires :public_ip_address, :username

          scp_options = {}
          scp_options[:password] = password unless self.password.nil?
          scp_options[:key_data] = [private_key] if self.private_key
          scp_options[:proxy]= ssh_proxy unless self.ssh_proxy.nil?

          Fog::SCP.new(public_ip_address, username, scp_options).upload(local_path, remote_path, upload_options)
        end


        # Sets up a new key
        def setup(credentials = {})
          requires :public_key, :public_ip_address, :username
          require 'multi_json'

          credentials[:proxy]= ssh_proxy unless ssh_proxy.nil?
          credentials[:password] = password unless self.password.nil?
          credentails[:key_data] = [private_key] if self.private_key

          commands = [
            %{mkdir .ssh},
            #              %{passwd -l #{username}}, #Not sure if we need this here
            #              %{echo "#{MultiJson.encode(attributes)}" >> ~/attributes.json}
          ]
          if public_key
            commands << %{echo "#{public_key}" >> ~/.ssh/authorized_keys}
          end

          # wait for domain to be ready
          Timeout::timeout(360) do
            begin
              Timeout::timeout(8) do
                Fog::SSH.new(public_ip_address, username, credentials.merge(:timeout => 4)).run('pwd')
              end
            rescue Errno::ECONNREFUSED
              sleep(2)
              retry
            rescue Net::SSH::AuthenticationFailed, Timeout::Error
              retry
            end
          end
          Fog::SSH.new(public_ip_address, username, credentials).run(commands)
        end

        # Retrieves the mac address from parsing the XML of the domain
        def mac
          mac = document("domain/devices/interface/mac", "address")
          return mac
        end

        def vnc_port

          port = document("domain/devices/graphics[@type='vnc']", "port")
          return port
        end


        private

        def raw
          @raw
        end

        def raw=(new_raw)
          @raw = new_raw

          raw_attributes = {
            :id => new_raw.uuid,
            :uuid => new_raw.uuid,
            :name => new_raw.name,
            :memory_size => new_raw.info.max_mem,
            :cpus => new_raw.info.nr_virt_cpu,
            :os_type => new_raw.os_type
          }

          merge_attributes(raw_attributes)
        end


        # finds a value from xml
        def document path, attribute=nil
          xml = REXML::Document.new(xml_desc)
          attribute.nil? ? xml.elements[path].text : xml.elements[path].attributes[attribute]
        end


      end

    end
  end

end
